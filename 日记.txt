2016/5/30
  我想把Filter的setMapping方法改掉，不再使用Pattern作为过滤的，改成对ControllerClass、ActionMethod作为参数传入，让方法返回boolean来判断是否匹配的，以此来将低使用者的门槛，因为还是有人不太适应正则表达式的，if判断要来的更直接粗暴，肯定也更好用，但是我还是放弃了，因为我改到一半又觉得，如果这样，那么系统在监控Filter的时候就不再那么直观，虽然使用简单了，灵活性也变大了，但是，这将带来很多不可预测的细节困难，比如层级不再清晰，因为这是针对类和方法的过滤了，和url不再有必然关系，所以Filter层级的管理就变得很困难，诸如此类等等，因此，我想要不要把Filter给策略模式一下，多几个不同类型的Filter来，当然其中有使用Pattern的Filter，有直接针对Class和Method的Filter，最后，我还是放弃了，我不想axe变得一团迷雾，我希望他干净，还是勿忘初衷吧。
  确实需要一个Interceptor了，当我想把/axe下的访问接口屏蔽起来的时候，使用Filter可不可以？不可以因为/axe已经FuckOff掉了所有Filter，不管你是谁，我都不让你过滤。那么给Filter加上一个新特性，让他可以在排除所有Filter的同时，放某一或某些指定接口进来呢？不行！我要过滤你，你可以排除我（排除所有也是排除我），但是不能你决定我来过滤你，这是职责明确，否则，就会看到很壮观的场面，有的人站在Action角度使用指定Filter来使用过滤器，有的人站在Filter角度来匹配Action，那样在想要知道这个Filter到底匹配了哪些Action的时候，就需要多渠道的去查看，这一个太让人恶心了，所以这种灵活不能要。

2016/6/2
  遇到一个奇怪的问题，ReflectionUtil的invoke方法，是采用反射的方式，调用被调用者，这在执行action method和持久层对bean执行set、get方法时候，都有用到，这里遇到一个问题，如果被调用的方法中，出现 1/0 这样的不需要catch的运行时异常，则在invoke时候无法捕捉，虽然控制台有打印异常，但是不会跳转到invoke的catch块，于是，我踏上了寻找解决办法的路途，首先，我认为，如果用cglib加一层代理，代理controller中所有方法，然后在代理中捕获throwable，然后再显式的抛给invoke，会不会解决，结果尼玛，不行，代理中也捕获不到，然后我改用MethodHandle来代替反射执行，依然捕获不到，不过这时候我发现，如果是使用jvm直接执行反射或者MethodHandle，也就是在Eclipse中执行main函数方法，是可以捕获到的，但是放在web容器中，通过请求，然后进调用action
method，就捕获不到，这就说明不是反射的问题了。也可能是web容器对反射的解析不一样。于是我回家后再次寻找解决之道，尼玛，结果再试一次，好使了，我不知道为什么。


2016/6/15
  今天已经是增加Captain工能第二天，进展比较缓慢，目前可以做到Captain上线，组员机上线，信息一致，组员机掉线，信息更新保持一致。接下去要做的是，captain下线，组员机产生Captain，继续保持信息一致。
  昨天晚上的版本，已经可以做到下发Team表，组员通过心跳通知Captain自己状态了，当时1台captain对4台组员，但是运行初还好，过段时间就cpu爆满，分析是io资源消耗太大。
  于是今天返工，把HttpUtil里的KeyAlive去掉了，目前还算稳定。
  #大混乱：
	当captain死掉，剩下的组员都根据自己手中的Team表第二人，来推举成为新任Captain，如果此时大家手里的表不一致，就会出现多个Captain的状况，怎么办？
	此时被称为乱世。
	这时候，可能会纷争成两排，各自有个Captain，都领着自己的组员，互不干涉，或者更极端的出现很多个小组碎片，都各自为政。
	目前，这种情况，只能通过人工合并碎片，最后合成一个大的小组，一个Captain了。
	不过，乱世概率，还是很小的。


2016/6/15
	昨天说Captain可能会遇到“乱世”的可能，昨晚已经做出了一个暂时的苟且对策，当发现“乱世”后，可以通过访问/captain/teamTable提交并新表来替换Captain的Team表，这个url是PUT类型的，GET方式访问只能获取，而且，
因为Captain才能修订Team表并下发给组员，所以只有修改Captain的表才有效。
	顺便说一说，为什么Axe会有Mast分支暂停开发，反而一直在更新branch jdk1.7分支呢？
	哎，这里要说说了，当时年纪轻啊，看到1.8新，于是Axe的出生就基于jdk 1.8来做的，然而一个好用的工具，应该是要不断被使用，不断被改进的，所以为了在现有的项目中大量实践axe，不得不双线并发，开了个branch jdk1.7分支，
那时候的axe还非常小，慢慢的，axe的实践越来越多，branch jdk1.7与mast分支的差异就越来越大，所以mast就暂停开发了，其实mast也只是多了一个lamda表达式和Stream的使用，还有就是反射方面的api差别。
	目前来看，branch1.7会一直稳定的更新下去，mast不删，后面可能会调整，axe也一定会跟着jdk的发展脚步，结合实际使用情况，不断更新自己的。
 
2016/9/23
	昨天有了大的发展，因为拖沓已久的自动建表，在昨天算是告一段落，这次提交实现了create table if not exit的模式，这个过程发生在框架启动之后的立马，当然需不需要axe帮我们自动建表，还是可以通过参数配置关闭打开的，就像其他orm框架比如hibernate一样。不过不同的是，axe提供的自动建表，比较简，只提供了建表功能，也就是，你要axe帮你建表可以，要他帮你删了，不行，要他帮你改表，不行，为什么只提供这一锤子买卖，因为我这个小程序员发现，使用hibernate当然也有自动建表功能，他可以通过配置hibernate.hbm2ddl.auto这个参数来选择自动建表的模式，那么他除了create以外，还提供了drop和update，后两者是什么呢，想必大家都是不陌生的，比如update，他能检测到你的pojo类发生结构变化，那么相应的修改对应的 表结构，但是，这里我们经常发现，比如你把某个Pojo类A的set、get字段field给改名儿了，那么原来的名字对应的数据库表的字段，不会删掉，还留着，然后新多出来个字段，唉~就是改了的这个字段名儿对应，这，基本我都得删掉那个字段，这是update的时候，还有drop，那有时候，我是不想我的表被删掉的，虽然那样彻底了，但是数据也直接没了，所以这两种场景都不够不够不够通用，不能完全完全放手，所以，我就不想给axe加了，自动建表已经在开发时候给我们省下很多力气，当在开发时出现字段变更，也只要手动drop下表，再启动框架就会给建上，如果不想重来，也可以自己alter table，框架发现表还在，就不会管你的。
	
2016/11/20
	多数据源的问题有了阶段性的改良，现在支持多数据源了，@Table注解有一个可选项是dataSource，默认是空串，意思是交由框架自己决策，一般决策结果就是默认数据源，
默认数据源在没有特殊配置的时候就是指axe包内的dbcp数据源，如果有外部配置，如果是多个数据源，反正就是取配置数据源中的第一个。
	由于axe可以支持不使用@Table注解来表示Entity结构，非常干净，所以数据源在指定的时候，会有两个地方，一个是Table上的@Table注解，一个是Dao上的@DataSource，
那么问题就来了，到底以谁为准呢，我想了一晚上，如果采用优先级策略，那么就会出现"你"覆盖"我"的情况，这样在排查时候就会非常恶心，我不喜欢，所以，我就采用了
单一职责的样式，应为Dao如果是继承了BaseDaoRepostory的话，会拥有一些entity操作，这些操作能够获取到Table上的@Table注解，所以只会认准@Table指定的数据源，
如果@Table不指定，就会采用默认数据源。那么如果Dao有@DataSource注解，则@DataSource指定的数据源，影响的是@SQL标注方法的数据源。所以如果不是默认数据源，为了前后一致，
就建议要在Entity上标注@Table指定数据源，并且在Dao上也要使用@DataSource指定相同数据源，以免出现混乱。
	