2016/5/30
  我想把Filter的setMapping方法改掉，不再使用Pattern作为过滤的，改成对ControllerClass、ActionMethod作为参数传入，让方法返回boolean来判断是否匹配的，以此来将低使用者的门槛，因为还是有人不太适应正则表达式的，if判断要来的更直接粗暴，肯定也更好用，但是我还是放弃了，因为我改到一半又觉得，如果这样，那么系统在监控Filter的时候就不再那么直观，虽然使用简单了，灵活性也变大了，但是，这将带来很多不可预测的细节困难，比如层级不再清晰，因为这是针对类和方法的过滤了，和url不再有必然关系，所以Filter层级的管理就变得很困难，诸如此类等等，因此，我想要不要把Filter给策略模式一下，多几个不同类型的Filter来，当然其中有使用Pattern的Filter，有直接针对Class和Method的Filter，最后，我还是放弃了，我不想axe变得一团迷雾，我希望他干净，还是勿忘初衷吧。
  确实需要一个Interceptor了，当我想把/axe下的访问接口屏蔽起来的时候，使用Filter可不可以？不可以因为/axe已经FuckOff掉了所有Filter，不管你是谁，我都不让你过滤。那么给Filter加上一个新特性，让他可以在排除所有Filter的同时，放某一或某些指定接口进来呢？不行！我要过滤你，你可以排除我（排除所有也是排除我），但是不能你决定我来过滤你，这是职责明确，否则，就会看到很壮观的场面，有的人站在Action角度使用指定Filter来使用过滤器，有的人站在Filter角度来匹配Action，那样在想要知道这个Filter到底匹配了哪些Action的时候，就需要多渠道的去查看，这一个太让人恶心了，所以这种灵活不能要。



2016/6/2
  遇到一个奇怪的问题，ReflectionUtil的invoke方法，是采用反射的方式，调用被调用者，这在执行action method和持久层对bean执行set、get方法时候，都有用到，这里遇到一个问题，如果被调用的方法中，出现 1/0 这样的不需要catch的运行时异常，则在invoke时候无法捕捉，虽然控制台有打印异常，但是不会跳转到invoke的catch块，于是，我踏上了寻找解决办法的路途，首先，我认为，如果用cglib加一层代理，代理controller中所有方法，然后在代理中捕获throwable，然后再显式的抛给invoke，会不会解决，结果尼玛，不行，代理中也捕获不到，然后我改用MethodHandle来代替反射执行，依然捕获不到，不过这时候我发现，如果是使用jvm直接执行反射或者MethodHandle，也就是在Eclipse中执行main函数方法，是可以捕获到的，但是放在web容器中，通过请求，然后进调用action
method，就捕获不到，这就说明不是反射的问题了。也可能是web容器对反射的解析不一样。于是我回家后再次寻找解决之道，尼玛，结果再试一次，好使了，我不知道为什么。